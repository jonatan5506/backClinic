# üöÄ NESTJS Task Manager API

## Vis√£o Geral do Projeto

Este projeto √© uma **API de Gerenciamento de Tarefas** (CRUD de `Task` e `User`) desenvolvida com o objetivo principal de aprofundar os estudos no **framework NestJS**. A arquitetura foca na utiliza√ß√£o de conceitos como **M√≥dulos**, **Servi√ßos**, **Controladores**, **DTOs** (Data Transfer Objects), **TypeORM** para persist√™ncia e **Guards** para seguran√ßa e autentica√ß√£o.

O foco principal foi a implementa√ß√£o de:

* **Autentica√ß√£o JWT** (JSON Web Tokens) com *Guards* globais.
* **Valida√ß√£o de Dados** utilizando `class-validator` e `class-transformer`.
* Estrutura de *migrations* para controle de esquema do **PostgreSQL**.

---

## üõ†Ô∏è Tecnologias e Ferramentas

| Categoria | Tecnologia | Fun√ß√£o no Projeto |
| :--- | :--- | :--- |
| **Backend** | **NestJS** | Framework Node.js para constru√ß√£o da API. |
| **Linguagem** | **TypeScript** | Superset do JavaScript com tipagem est√°tica. |
| **Banco de Dados** | **PostgreSQL** | Sistema de gerenciamento de banco de dados relacional. |
| **ORM** | **TypeORM** | Mapeamento Objeto-Relacional para interagir com o PostgreSQL. |
| **Containers** | **Docker Compose** | Usado para configurar e orquestrar o ambiente local do banco de dados. |
| **Implanta√ß√£o** | **AWS EC2** | Plataforma de *hosting* onde o projeto pode ser executado. |

---

## üì¶ Depend√™ncias Chave

O projeto utiliza bibliotecas essenciais para manter a qualidade do c√≥digo e a seguran√ßa dos dados.

| Depend√™ncia | Prop√≥sito | Detalhes |
| :--- | :--- | :--- |
| **`class-validator`** | **Valida√ß√£o de Entradas** | Permite definir regras de valida√ß√£o (tamanho, formato, tipo) usando decoradores em DTOs. O NestJS utiliza um **`ValidationPipe`** global para aplicar estas regras automaticamente. |
| **`class-transformer`** | **Transforma√ß√£o de Dados** | Usado para converter *plain objects* (JSON) em inst√¢ncias de classes e vice-versa. √â crucial para **excluir campos sens√≠veis** (como senhas) nas respostas ou transformar tipos de dados. |
| **`@nestjs/jwt`** | **Autentica√ß√£o (JWT)** | Implementa o uso de **JSON Web Tokens** para verificar a identidade do usu√°rio. O token gerado deve ser enviado em todas as requisi√ß√µes protegidas. |

nestjs
‚îî‚îÄ
  ‚îú‚îÄ .env
   ‚îú‚îÄ .env.example
   ‚îú‚îÄ docker-compose.yml
   ‚îú‚îÄ src
   ‚îÇ  ‚îú‚îÄ app.module.ts
   ‚îÇ  ‚îú‚îÄ auth              # L√≥gica de Autentica√ß√£o (Login, JWT)
   ‚îÇ  ‚îÇ  ‚îî‚îÄ auth.guard.ts  
   ‚îÇ  ‚îú‚îÄ db                # Configura√ß√£o do TypeORM
   ‚îÇ  ‚îÇ  ‚îî‚îÄ migrations     # Arquivos de schema e seed (inclui SeedAdminUser)
   ‚îÇ  ‚îú‚îÄ decorators        # Decoradores customizados (ex: @Public)
   ‚îÇ  ‚îú‚îÄ main.ts           # Ponto de entrada e pipes globais
   ‚îÇ  ‚îú‚îÄ task              # M√≥dulo CRUD de Tarefas
   ‚îÇ  ‚îÇ  ‚îî‚îÄ dto
   ‚îÇ  ‚îú‚îÄ users             # M√≥dulo CRUD de Usu√°rios
   ‚îÇ  ‚îÇ  ‚îî‚îÄ dto
   ‚îÇ  ‚îî‚îÄ ...
   ‚îî‚îÄ ...
 




### Configura√ß√£o Global de Pipes

O uso do `class-validator` e `class-transformer` √© habilitado globalmente em `main.ts` atrav√©s do **`ValidationPipe`**:







```typescript
// main.ts
// Aplica o pipe de valida√ß√£o em todos os endpoints
app.useGlobalPipes(new ValidationPipe());

// app.module.ts
providers: [
  // Aplica AuthGuard globalmente
  {
    provide: APP_GUARD,
    useClass: AuthGuard,
  },
],

// users.module.ts
// Deixa a entidade disponivel para o TypeORM
imports: [TypeOrmModule.forFeature([UserEntity])],



********************************************************************

// Importa o decorador @Module, essencial para definir um m√≥dulo no NestJS.
import { Module } from '@nestjs/common';
// Importa o AuthController, que lida com as requisi√ß√µes HTTP (rotas de login).
import { AuthController } from './auth.controller';
// Importa o m√≥dulo de usu√°rios. O AuthModule precisa dele para validar as credenciais do usu√°rio durante o login.
import { UsersModule } from '../users/users.module.js';
// Importa o JwtModule e os m√≥dulos de configura√ß√£o necess√°rios.
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';

// O decorador @Module define a estrutura deste m√≥dulo.
@Module({
  // A propriedade 'imports' lista outros m√≥dulos de que este m√≥dulo precisa.
  imports: [
    // Importa o m√≥dulo de configura√ß√£o.
    // √â obrigat√≥rio para que o 'registerAsync' do JwtModule consiga injetar o ConfigService.
    ConfigModule,

    // Configura o m√≥dulo JWT de forma ass√≠ncrona.
    // Isso permite injetar depend√™ncias (como o ConfigService) para buscar vari√°veis de ambiente.
    JwtModule.registerAsync({
      // Indica qual servi√ßo deve ser injetado para obter a configura√ß√£o.
      inject: [ConfigService],

      // Fun√ß√£o de f√°brica usada para construir a configura√ß√£o do JwtModule.
      // Ela recebe o ConfigService injetado como argumento.
      useFactory: (configService: ConfigService) => {
        // As linhas abaixo s√£o coment√°rios de debug (comentadas) que voc√™ usou.
        // Elas mostrariam o valor das vari√°veis de ambiente no console.
        // console.log('JWT_SECRET ->', configService.get<string>('JWT_SECRET'));
        /* console.log(
          'JWT_EXPIRATION_TIME ->',
          configService.get<number>('JWT_EXPIRATION_TIME'),
        );  */ // debug

        // Retorna o objeto de configura√ß√£o do JWT.
        return {
          // Define a chave secreta (secret) usada para assinar/verificar tokens.
          // Busca o valor de 'JWT_SECRET' no .env ou usa um 'fallback-secret' (n√£o recomendado em produ√ß√£o).
          secret: configService.get<string>('JWT_SECRET') /* || 'fallback-secret' */,

          // Op√ß√µes para a assinatura do token.
          signOptions: {
            // Define o tempo de expira√ß√£o (expiresIn) do token.
            // Busca o valor de 'JWT_EXPIRATION_TIME' (em segundos) ou usa 7200s (2 horas) como padr√£o.
            // O `${...}s` √© usado para garantir que o tempo de expira√ß√£o seja lido como segundos.
            expiresIn: `${configService.get<number>('JWT_EXPIRATION_TIME') ?? 7200}s`,
          },
        };
      },
    }),

    // O UsersModule √© importado para que o AuthService possa acessar o UsersService
    // (e suas funcionalidades, como encontrar um usu√°rio por login/senha) durante a tentativa de login.
    UsersModule,
  ],

  // A propriedade 'controllers' registra todos os controladores que pertencem a este m√≥dulo.
  // Neste caso, o AuthController cont√©m as rotas como /auth/login.
  controllers: [AuthController],

  // A propriedade 'providers' registra os servi√ßos e outras classes que podem ser injetadas.
  // O AuthService cont√©m a l√≥gica de neg√≥cios para autentica√ß√£o (comparar senhas, gerar o token, etc.).
  providers: [AuthService],
})
// Define a classe do m√≥dulo. O nome da classe deve terminar em 'Module' por conven√ß√£o.
export class AuthModule {}


***********************************************************************************

import {
  CanActivate, // Interface que o Guard deve implementar (possui o m√©todo canActivate).
  ExecutionContext, // Objeto que fornece acesso ao contexto da requisi√ß√£o (HTTP, WebSocket, etc.).
  Injectable, // Permite que a classe seja injetada e injete depend√™ncias.
  UnauthorizedException, // Exce√ß√£o HTTP 401, usada para bloquear o acesso.
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config'; // Servi√ßo para ler vari√°veis de ambiente (JWT_SECRET).
import { JwtService } from '@nestjs/jwt'; // Servi√ßo para verificar a validade do token.
import { Request } from 'express'; // Tipagem base do objeto de requisi√ß√£o.
import { Reflector } from '@nestjs/core'; // Usado para ler metadados de decoradores (como o @Public()).
import { UserEntity } from '../users/entities/user.entity'; // Entidade do usu√°rio para tipagem.
import { IS_PUBLIC_KEY } from '../decorators/public.decorator'; // Chave de metadado que marca rotas p√∫blicas.

// Estende a interface base do Request para incluir o objeto 'user'
// depois que o token for decodificado.
interface RequestWithUser extends Request {
  user: UserEntity;
}

@Injectable()
export class AuthGuard implements CanActivate {
  // O constructor injeta os servi√ßos necess√°rios.
  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly reflector: Reflector,
  ) {}

  // O m√©todo principal que decide se a requisi√ß√£o pode prosseguir.
  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 1. Checa rotas p√∫blicas
    
    // Tenta ler o metadado IS_PUBLIC_KEY na fun√ß√£o (handler) e na classe.
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(), // Verifica se est√° no m√©todo do controller
      context.getClass(), // Verifica se est√° no controller inteiro
    ]);
    
    // Se a rota for marcada como p√∫blica, o Guard √© ignorado e o acesso √© permitido.
    if (isPublic) return true;

    // 2. Extrai Request e Token
    
    // Obt√©m o objeto Request e o tipa corretamente (incluindo 'user').
    const request = context.switchToHttp().getRequest<RequestWithUser>();
    
    // Extrai o token do cabe√ßalho de autoriza√ß√£o.
    const token = this.extractTokenFromHeader(request);

    // Se o token n√£o existir (cabe√ßalho vazio ou mal formatado), lan√ßa 401.
    if (!token) {
      throw new UnauthorizedException('Token n√£o fornecido.');
    }

    // 3. Verifica Token
    try {
      // Obt√©m a chave secreta de forma s√≠ncrona do .env.
      const secret = this.configService.getOrThrow('JWT_SECRET')!;
      
      // Verifica o token usando a chave secreta. Isso tamb√©m valida a expira√ß√£o.
      const payload = await this.jwtService.verifyAsync(token, {
        secret,
      });

      // Anexa o payload (o objeto do usu√°rio) √† requisi√ß√£o.
      // Agora, outros servi√ßos e controllers podem acessar 'request.user'.
      request.user = payload;
      
    } catch {
      // Se a verifica√ß√£o falhar (expirado, modificado, etc.), lan√ßa 401.
      throw new UnauthorizedException('Token inv√°lido.');
    }

    // 4. Conex√£o Autorizada
    
    // Se tudo estiver OK, permite que a requisi√ß√£o siga para o Controller.
    return true;
  }

  // M√©todo de Extra√ß√£o: Pega o token no formato "Bearer token".
  private extractTokenFromHeader(request: Request): string | undefined {
    // Divide o cabe√ßalho 'Authorization' em [tipo, token].
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    
    // Retorna o token apenas se o tipo for "Bearer".
    return type === 'Bearer' ? token : undefined;
  }
}


************************************************************************************


# NESTJS

Projeto criado com intuito de estudar o framewok nestjs, modulos,decorators...

utilizei 

Node.js
Nestjs
Typescritp
Aws ec2
Postgresql
typeorm


Class-transformer - Ia deve explicar
Class validator - Ia deve explicar
jwt - Ia deve explicar


nestjs
‚îî‚îÄ curso-nest
   ‚îú‚îÄ .env
   ‚îú‚îÄ .env.example
   ‚îú‚îÄ .prettierrc
   ‚îú‚îÄ README.md
   ‚îú‚îÄ docker-compose.yml
   ‚îú‚îÄ eslint.config.mjs
   ‚îú‚îÄ nest-cli.json
   ‚îú‚îÄ package-lock.json
   ‚îú‚îÄ package.json
   ‚îú‚îÄ src
   ‚îÇ  ‚îú‚îÄ app.module.ts
   ‚îÇ  ‚îú‚îÄ app.service.ts
   ‚îÇ  ‚îú‚îÄ auth
   ‚îÇ  ‚îÇ  ‚îú‚îÄ auth.controller.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ auth.guard.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ auth.module.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ auth.service.ts
   ‚îÇ  ‚îÇ  ‚îî‚îÄ dto
   ‚îÇ  ‚îÇ     ‚îî‚îÄ auth.response.dto.ts
   ‚îÇ  ‚îú‚îÄ db
   ‚îÇ  ‚îÇ  ‚îú‚îÄ db.module.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ entities
   ‚îÇ  ‚îÇ  ‚îú‚îÄ migrations
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ 1759517775476-task-table.ts
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ 1759517810637-user-table.ts
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ 1759532024820-SeedAdminUser.ts
   ‚îÇ  ‚îÇ  ‚îî‚îÄ typeOrm.migration-config.ts
   ‚îÇ  ‚îú‚îÄ decorators
   ‚îÇ  ‚îÇ  ‚îî‚îÄ public.decorator.ts
   ‚îÇ  ‚îú‚îÄ main.ts
   ‚îÇ  ‚îú‚îÄ task
   ‚îÇ  ‚îÇ  ‚îú‚îÄ dto
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ create-task.dto.ts
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ response-task.dto.ts
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ update-task.dto.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ entities
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ task.entity.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ enum
   ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ task.enum.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ task.controller.ts
   ‚îÇ  ‚îÇ  ‚îú‚îÄ task.module.ts
   ‚îÇ  ‚îÇ  ‚îî‚îÄ task.service.ts
   ‚îÇ  ‚îî‚îÄ users
   ‚îÇ     ‚îú‚îÄ dto
   ‚îÇ     ‚îÇ  ‚îú‚îÄ create-user.dto.ts
   ‚îÇ     ‚îÇ  ‚îî‚îÄ update-user.dto.ts
   ‚îÇ     ‚îú‚îÄ entities
   ‚îÇ     ‚îÇ  ‚îî‚îÄ user.entity.ts
   ‚îÇ     ‚îú‚îÄ users.controller.ts
   ‚îÇ     ‚îú‚îÄ users.module.ts
   ‚îÇ     ‚îî‚îÄ users.service.ts
   ‚îú‚îÄ tsconfig.build.json
   ‚îî‚îÄ tsconfig.json

- nest g res task

Projeto utiliza Guards em todas as rotas, exceto na rota de Login - TODO retirar Guards da rota Cria usu√°rio 
1¬∫ realizo Login
usuario padr√£o 
admin
admin

2¬∫ pego o token e coloco em
 - Autorization
 - barer token

 para realizar as demais a√ß√µes do crud

 ## Valida√ß√µes

 - npm i class-validator class-transformer

 ## Typeorm
 - npm i typeorm @nestjs/typeorm
 - instalar pacote do db - npm i pg
 - criar docker-compose.yml
 - criar modulo db
 - instalar dotenv para usar na migration - npm i dotenv
 - passar atributo name ao criar migration - npm run migration:create -name=task-table

 OBS: Antes de primeiro login, rodar as migrations para criar o usu√°rio "admin".

come√ßar falando do 
main

//Para usar o Class-transformer e Class-validator
  app.useGlobalPipes(new ValidationPipe());

appModule

 // Aplica AuthGuard globalmente
   provide: APP_GUARD,
   useClass: AuthGuard,

usermodule
//Deixa a entidade disponivel para o typeorm
  imports: [TypeOrmModule.forFeature([UserEntity])],

postgresql://postgres:postgres@natandevdb.duckdns.org:5432/db_task

OBS:
* Comando para verificar cria√ß√£o de db: docker exec -it postgres_db psql -U postgres -l


//TASKS
- rota signUp ok
- rota signIn ok

//TODO
- implementar login com google
  - npm install @nestjs/passport passport passport-google-oauth20
  - npm install --save-dev @types/passport-google-oauth20

  - login com Google / verificar credenciais .env
    # tem que adicionar a URL do front "http://localhost:5173/" na cria√ß√£o das credenciais
    e a Url: http://localhost:8000/auth/google/callback na credencial url de redirecionameto

  deu esse erro no back:

   ERROR [ExceptionsHandler] TypeError: this.authService.signInWithGoogle is not a function
    at AuthController.googleAuthRedirect (/home/jhon/Desktop/ALURA/argus/Acesi/backClinic/back/src/auth/auth.controller.ts:57:42)
    at /home/jhon/Desktop/ALURA/argus/Acesi/backClinic/back/node_modules/@nestjs/core/router/router-execution-context.js:38:29
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async /home/jhon/Desktop/ALURA/argus/Acesi/backClinic/back/node_modules/@nestjs/core/router/router-execution-context.js:46:28
    at async /home/jhon/Desktop/ALURA/argus/Acesi/backClinic/back/node_modules/@nestjs/core/router/router-proxy.js:9:17
^C


  /* Rode o NestJS: npm run start:dev
  Acesse: http://localhost:3000/auth/google
  O Google pedir√° login e, ap√≥s autenticar, voc√™ ser√° redirecionado para http://localhost:3000/auth/google/callback com os dados do usu√°rio. */